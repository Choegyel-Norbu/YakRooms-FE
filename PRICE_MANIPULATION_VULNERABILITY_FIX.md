# üîê Price Manipulation Vulnerability - Complete Fix

## Risk Assessment
**Risk Score**: 8.6/10 (CRITICAL)
**Category**: Price Manipulation via Parameter Tampering
**Impact**: Direct revenue loss, fraudulent transactions, legal liabilities

---

## üéØ The Vulnerability

### Current Problematic Flow:
```
Client calculates price ‚Üí Client sends price to server ‚Üí Server trusts price ‚Üí Payment processed
```

### Attack Vector:
1. User opens browser DevTools
2. Intercepts the POST request to `/api/bookings`
3. Modifies `totalPrice: 5000` to `totalPrice: 1`
4. Modifies `txnTotalPrice: 5150` to `txnTotalPrice: 1`
5. Server accepts the tampered price
6. **Result**: User pays Nu. 1 instead of Nu. 5,000

### Real-World Scenario:
```javascript
// BEFORE (Vulnerable):
const payload = {
  roomId: 123,
  checkInDate: "2025-11-15",
  checkOutDate: "2025-11-17",
  totalPrice: 5000,        // ‚ùå Can be changed to 1
  txnTotalPrice: 5150,     // ‚ùå Can be changed to 1
  // ... other fields
};
```

---

## ‚úÖ The Solution

### Secure Flow Architecture:
```
Client sends booking details only ‚Üí Server fetches room price from DB ‚Üí 
Server calculates price ‚Üí Server validates ‚Üí Payment processed
```

### Implementation Strategy:

#### 1. **Remove Client-Side Price Submission** ‚úÖ
**What Changed**:
- Removed `totalPrice` and `txnTotalPrice` from client payloads
- Client still calculates prices for **display purposes only**
- Server ignores any price data from client (defense in depth)

**Files Modified**:
- `src/features/booking/TimeBasedBookingDialog.jsx`
- `src/features/booking/RoomBookingCard.jsx`
- `src/features/guest/GuestDashboard.jsx` (for extensions)
- `src/features/hotel/AdminBookingForm.jsx`

#### 2. **Server-Side Price Recalculation** (Backend Required)
**Backend Must**:
```java
// Spring Boot Example (Backend Implementation)
@PostMapping("/bookings")
public BookingResponse createBooking(@RequestBody BookingRequest request) {
    // ‚úÖ NEVER trust client prices - recalculate everything
    
    // 1. Fetch room from database
    Room room = roomRepository.findById(request.getRoomId())
        .orElseThrow(() -> new NotFoundException("Room not found"));
    
    // 2. Calculate price on server
    double basePrice;
    if (request.isTimeBased()) {
        basePrice = room.getPrice(); // Hourly rate
    } else {
        long days = ChronoUnit.DAYS.between(
            request.getCheckInDate(), 
            request.getCheckOutDate()
        );
        basePrice = room.getPrice() * days;
    }
    
    // 3. Apply business logic
    double totalPrice = Math.ceil(basePrice * request.getNumberOfRooms());
    double serviceTax = totalPrice * 0.03;
    double txnTotalPrice = Math.ceil(totalPrice + serviceTax);
    
    // 4. Validate against client values (if sent) - log discrepancies
    if (request.getTotalPrice() != null && 
        Math.abs(request.getTotalPrice() - totalPrice) > 0.01) {
        // ‚ö†Ô∏è SECURITY ALERT: Price mismatch detected
        securityLogger.logPriceTampering(request, totalPrice, txnTotalPrice);
        throw new SecurityException("Price validation failed");
    }
    
    // 5. Use server-calculated prices for payment
    booking.setTotalPrice(totalPrice);
    booking.setTxnTotalPrice(txnTotalPrice);
    
    // 6. Proceed with payment using SERVER prices only
    PaymentResponse payment = paymentService.initiatePayment(
        booking.getTxnTotalPrice() // ‚úÖ Server-calculated price
    );
    
    return new BookingResponse(booking, payment);
}
```

#### 3. **Request Integrity Verification** üîê
**Add HMAC Signature**:
```javascript
// Client generates signature with timestamp
const generateRequestSignature = (payload, timestamp) => {
  // Backend provides this key during session init (NOT in client code)
  const sessionKey = getSessionIntegrityKey(); 
  const dataToSign = JSON.stringify({...payload, timestamp});
  return CryptoJS.HmacSHA256(dataToSign, sessionKey).toString();
};

// Add to request headers
headers: {
  'X-Request-Signature': signature,
  'X-Request-Timestamp': timestamp
}
```

**Backend Verification**:
```java
// Verify signature and timestamp
public void verifyRequestIntegrity(String signature, String timestamp, String body) {
    // Check timestamp freshness (prevent replay attacks)
    long requestTime = Long.parseLong(timestamp);
    long currentTime = System.currentTimeMillis();
    if (currentTime - requestTime > 30000) { // 30 second window
        throw new SecurityException("Request expired");
    }
    
    // Verify HMAC signature
    String expectedSignature = generateHMAC(body + timestamp, sessionKey);
    if (!signature.equals(expectedSignature)) {
        securityLogger.logInvalidSignature(request);
        throw new SecurityException("Invalid request signature");
    }
}
```

#### 4. **Transaction Monitoring & Anomaly Detection** üìä
**Log Everything**:
```java
@Entity
public class PaymentAuditLog {
    private Long bookingId;
    private Long userId;
    private Double clientPrice;      // What client sent (if any)
    private Double serverPrice;      // What server calculated
    private Double actualCharged;    // What was actually charged
    private Double discrepancy;      // Difference
    private String ipAddress;
    private String userAgent;
    private LocalDateTime timestamp;
    private Boolean suspicious;      // Flag for review
}
```

**Anomaly Detection Rules**:
```java
// Flag suspicious transactions
public boolean isSuspiciousTransaction(BookingRequest request, double serverPrice) {
    // Rule 1: Client price significantly lower than server price
    if (request.getTotalPrice() != null && 
        request.getTotalPrice() < serverPrice * 0.5) {
        return true;
    }
    
    // Rule 2: Unusual patterns (e.g., multiple low-price attempts)
    long recentLowPriceAttempts = auditRepository
        .countSuspiciousAttemptsInLastHour(request.getUserId());
    if (recentLowPriceAttempts > 3) {
        return true;
    }
    
    // Rule 3: Price rounds to suspicious values (1, 10, 100)
    if (request.getTotalPrice() != null && 
        Arrays.asList(1.0, 10.0, 100.0).contains(request.getTotalPrice())) {
        return true;
    }
    
    return false;
}
```

#### 5. **Rate Limiting & IP Blocking**
```java
// Implement rate limiting on booking endpoints
@RateLimiter(name = "bookingRateLimiter", fallbackMethod = "bookingRateLimitFallback")
@PostMapping("/bookings")
public BookingResponse createBooking(@RequestBody BookingRequest request) {
    // Implementation
}

// Block IPs with repeated suspicious activity
if (isSuspiciousTransaction(request, serverPrice)) {
    ipBlockingService.incrementSuspicionScore(request.getIpAddress());
    if (ipBlockingService.shouldBlockIp(request.getIpAddress())) {
        throw new SecurityException("Access denied");
    }
}
```

---

## üîß Frontend Changes (This Repository)

### Key Modifications:

1. **Removed price parameters from booking payloads** ‚úÖ
   - Prices now calculated for **display only**
   - Not sent to backend (or sent for validation only)
   - Backend recalculates everything

2. **Added security utilities** ‚úÖ
   - Request signature generation (when backend ready)
   - Transaction ID tracking
   - Anomaly detection helpers

3. **Enhanced error handling** ‚úÖ
   - Detect price validation failures
   - Show user-friendly messages
   - Log security events

### Files Modified:
```
‚úÖ src/features/booking/TimeBasedBookingDialog.jsx
‚úÖ src/features/booking/RoomBookingCard.jsx
‚úÖ src/features/guest/GuestDashboard.jsx
‚úÖ src/features/hotel/AdminBookingForm.jsx
‚úÖ src/shared/utils/securityUtils.js (NEW)
‚úÖ src/shared/services/bookingSecurityService.js (NEW)
```

---

## üéØ Backend Requirements (Critical)

### Must Implement:

#### ‚úÖ 1. **Server-Side Price Calculation**
```java
// Always recalculate prices from database
double serverPrice = calculatePriceFromDatabase(roomId, dates, guests);
```

#### ‚úÖ 2. **Price Validation**
```java
// Validate and log discrepancies
if (clientPrice != null && Math.abs(clientPrice - serverPrice) > 0.01) {
    securityAuditService.logPriceTampering(request);
    // Option A: Reject request
    throw new SecurityException("Price validation failed");
    // Option B: Use server price and log
    logger.warn("Price mismatch: client={}, server={}", clientPrice, serverPrice);
}
```

#### ‚úÖ 3. **Use Server Prices for Payment**
```java
// NEVER use client-provided prices for payment
paymentService.initiatePayment(
    booking.getId(),
    serverCalculatedPrice  // ‚úÖ Not clientProvidedPrice
);
```

#### ‚úÖ 4. **Audit Logging**
```java
// Log every transaction attempt
auditLogger.log(new TransactionAudit()
    .setUserId(userId)
    .setBookingId(bookingId)
    .setClientPrice(clientPrice)
    .setServerPrice(serverPrice)
    .setActualCharged(actualCharged)
    .setIpAddress(request.getRemoteAddr())
    .setUserAgent(request.getHeader("User-Agent"))
    .setSuspicious(clientPrice != null && clientPrice < serverPrice)
);
```

#### ‚úÖ 5. **Security Monitoring Dashboard**
Create admin dashboard to monitor:
- Price discrepancies
- Suspicious patterns
- Blocked IPs
- Failed validation attempts

---

## üß™ Testing the Fix

### Manual Testing:

1. **Intercept Request with Browser DevTools**:
   ```javascript
   // Open DevTools ‚Üí Network Tab ‚Üí Find POST /api/bookings
   // Right-click ‚Üí Edit and Resend
   // Try to modify payload (should not have price fields now)
   ```

2. **Test with Burp Suite/Postman**:
   ```json
   POST /api/bookings
   {
     "roomId": 123,
     "checkInDate": "2025-11-15",
     "checkOutDate": "2025-11-17",
     "totalPrice": 1,  // Try to inject low price
     "txnTotalPrice": 1
   }
   // Expected: Backend should ignore these and use server-calculated prices
   ```

3. **Verify Server Logs**:
   ```
   [SECURITY] Price tampering detected:
     User: 456
     Room: 123
     Client Price: 1.00
     Server Price: 5000.00
     Action: Used server price, flagged user
   ```

### Automated Tests:

```java
@Test
public void testPriceManipulation_ShouldUseServerPrice() {
    BookingRequest request = new BookingRequest();
    request.setRoomId(123L);
    request.setCheckInDate(LocalDate.now());
    request.setCheckOutDate(LocalDate.now().plusDays(2));
    request.setTotalPrice(1.0); // Tampered price
    
    BookingResponse response = bookingController.createBooking(request);
    
    // Verify server recalculated the price
    assertEquals(5000.0, response.getBooking().getTotalPrice());
    
    // Verify security log was created
    verify(securityLogger).logPriceTampering(any());
}
```

---

## üìä Monitoring & Alerts

### Set Up Alerts:
1. **Price Discrepancy Alert**: Email when |clientPrice - serverPrice| > 1000
2. **Multiple Failed Attempts**: Alert when user has 3+ suspicious transactions
3. **Revenue Impact**: Daily report of blocked fraudulent attempts
4. **IP Blocking**: Notify when IPs are auto-blocked

### Metrics to Track:
- Number of price tampering attempts
- Average price discrepancy
- Blocked transactions (potential revenue saved)
- False positives (legitimate requests blocked)

---

## ‚úÖ Verification Checklist

- [x] Client no longer sends `totalPrice` and `txnTotalPrice` in booking requests
- [ ] Backend recalculates all prices from database
- [ ] Backend ignores any client-provided prices
- [ ] Backend validates room prices against database
- [ ] Payment gateway receives ONLY server-calculated prices
- [ ] Audit logging implemented for all transactions
- [ ] Security monitoring dashboard created
- [ ] Anomaly detection rules configured
- [ ] Rate limiting enabled on booking endpoints
- [ ] IP blocking mechanism in place
- [ ] Security alerts configured
- [ ] Penetration testing completed
- [ ] Team trained on secure payment handling

---

## üéì Best Practices Going Forward

### Golden Rules:
1. **Never trust client input** - Especially for financial data
2. **Always recalculate on server** - Prices, taxes, discounts
3. **Validate everything** - Check against business rules
4. **Log extensively** - Audit all financial transactions
5. **Monitor actively** - Set up alerts for anomalies
6. **Test regularly** - Include security testing in CI/CD
7. **Educate team** - Everyone should understand these risks

### Code Review Checklist:
- [ ] Are we sending financial data from client?
- [ ] Does server recalculate prices?
- [ ] Is there proper validation?
- [ ] Are we logging this transaction?
- [ ] Could this be exploited?

---

## üìö Additional Security Measures

### Consider Implementing:

1. **Two-Factor Authentication** for high-value bookings
2. **Device Fingerprinting** to track suspicious users across sessions
3. **Machine Learning** for advanced fraud detection
4. **Manual Review Queue** for flagged transactions
5. **Webhook Verification** for payment callbacks
6. **Regular Security Audits** by third parties
7. **Bug Bounty Program** to crowdsource security testing

---

## üîó Related Documentation

- `COMPLETE_SECURITY_SUMMARY.md` - Overall security posture
- `SECURITY_FIX_GUIDE.md` - General security guidelines
- `README_SECURITY.md` - Security for developers

---

## üìû Questions?

If you have questions about this fix or need help implementing the backend changes, please:
1. Review this document thoroughly
2. Check the modified frontend files
3. Consult with your backend team
4. Consider hiring a security consultant for review

**Remember**: This is a CRITICAL vulnerability. It should be fixed immediately and thoroughly tested before deploying to production.

---

*Document created: November 10, 2025*
*Last updated: November 10, 2025*
*Severity: CRITICAL (8.6/10)*
*Status: Frontend Fixed ‚úÖ | Backend Implementation Required ‚ö†Ô∏è*

